LISTA DE EXERCÍCIOS ADICIONAIS - PROGRAMAÇÃO FUNCIONAL
Disciplina: Programação Funcional - Haskell
===============================================================================

1. Utilizando list comprehension, calcule a soma dos cubos dos números ímpares 
   de 1 a 50.
   {-exemplo-}
   Main> sumOddCubes = 156816

2. Defina a função take' :: Int -> [a] -> [a] utilizando list comprehension,
   que retorna os primeiros n elementos de uma lista.
   {-exemplo-}
   Main> take' 3 [1,2,3,4,5] = [1,2,3]

3. Uma tripla (a, b, c) é uma progressão aritmética se b - a = c - b.
   Defina a função arithmetic :: Int -> [(Int, Int, Int)] que retorna todas
   as triplas em progressão aritmética até o limite fornecido.
   {-exemplo-}
   Main> arithmetic 10 = [(1,2,3),(2,3,4),(3,4,5),...,(6,8,10)]

4. Um número é abundante se a soma de seus divisores próprios é maior que
   ele mesmo. Defina a função abundant :: Int -> [Int] que retorna todos
   os números abundantes até o limite.
   {-exemplo-}
   Main> abundant 30 = [12,18,20,24,30]

5. Mostre como a list comprehension [x*y | x <- [1,2], y <- [3,4], x < y]
   pode ser reescrita usando duas list comprehensions aninhadas com concat.

6. Defina a função removeAll :: Eq a => a -> [a] -> [a] que remove todas
   as ocorrências de um elemento de uma lista, usando list comprehension.
   {-exemplo-}
   Main> removeAll 'a' "banana" = "bnn"

7. O produto vetorial de duas listas é a soma dos quadrados das diferenças
   dos elementos correspondentes: Σ(xi - yi)². Defina vectorProduct usando
   list comprehension.
   {-exemplo-}
   Main> vectorProduct [1,2,3] [4,5,6] = 27

8. Defina o operador de potenciação ^! usando recursão mútua, onde uma função
   trata casos pares e outra casos ímpares do expoente.

9. Mostre como [x | x <- xs, even x, x > 10] pode ser reescrita usando
   composição de funções filter e map.

10. Defina bin2int :: [Int] -> Int que converte uma lista binária em decimal.
    {-exemplo-}
    Main> bin2int [1,0,1,1] = 11

11. Use unfold para gerar a sequência de Fibonacci até um limite dado.
    {-exemplo-}
    Main> fibonacciSeq 100 = [1,1,2,3,5,8,13,21,34,55,89]

12. Defina oddSquares :: Int -> [Int] que retorna os quadrados dos números
    ímpares até o limite.
    {-exemplo-}
    Main> oddSquares 20 = [1,9,25,49,81,121,169,225,289,361]

13. Usando list comprehension, defina merge :: [Int] -> [Int] -> [Int] que
    mescla duas listas ordenadas mantendo a ordem.
    {-exemplo-}
    Main> merge [1,3,5] [2,4,6] = [1,2,3,4,5,6]

14. Escreva uma função countDivisors :: Int -> Int -> Int que conta quantos
    divisores um número tem em um intervalo usando list comprehension.
    {-exemplo-}
    Main> countDivisors 12 20 = 3  -- divisores de 12 entre 1 e 20

15. Implemente triplicate :: String -> String que retorna três cópias
    concatenadas de uma string usando list comprehension.
    {-exemplo-}
    Main> triplicate "abc" = "abcabcabc"

16. Implemente centerString :: String -> Int -> String que centraliza uma
    string adicionando espaços nas extremidades usando list comprehension.
    {-exemplo-}
    Main> centerString "hi" 6 = "  hi  "

17. Implemente reverseWords :: String -> String que inverte cada palavra
    individualmente em uma frase usando list comprehension.
    {-exemplo-}
    Main> reverseWords "hello world" = "olleh dlrow"

18. Dada uma lista de inteiros, retorne uma tripla (negativos, zeros, positivos)
    usando list comprehension obrigatoriamente.
    {-exemplo-}
    Main> classify [-2,0,3,-1,0,5] = ([-2,-1],[0,0],[3,5])

19. Converta uma lista de inteiros para uma string onde cada número vira
    seu equivalente em romano (I=1, V=5, X=10) usando list comprehension.
    {-exemplo-}
    Main> toRoman [1,5,10,1] = "IVXI"

20. Dada uma string e um caractere, retorne as posições onde o caractere
    aparece usando list comprehension.
    {-exemplo-}
    Main> findPositions "hello" 'l' = [2,3]

21. Implemente expandList :: [Int] -> [Int] que expande cada elemento n
    em uma sequência [1,2,...,n] usando list comprehension.
    {-exemplo-}
    Main> expandList [3,1,2] = [1,2,3,1,1,2]

22. Implemente compressChar :: String -> String que remove caracteres
    consecutivos duplicados usando list comprehension.
    {-exemplo-}
    Main> compressChar "aaabbbccc" = "abc"

23. Compare estas implementações de uma função que encontra o máximo:
    
    maxElement :: [Int] -> Int
    maxElement [x] = x
    maxElement (x:xs) = max x (maxElement xs)
    
    maxElement2 :: [Int] -> Int  
    maxElement2 [x] = x
    maxElement2 (x:xs) = let m = maxElement2 xs
                         in if x > m then x else m
    
    (a) Qual a diferença na avaliação?
    (b) Qual é mais eficiente em termos de memória?

24. Analise estas funções que verificam se uma lista está ordenada:
    
    isSorted :: Ord a => [a] -> Bool
    isSorted [] = True
    isSorted [_] = True  
    isSorted (x:y:xs) = x <= y && isSorted (y:xs)
    
    isSorted2 :: Ord a => [a] -> Bool
    isSorted2 xs = xs == sort xs
    
    (a) Explique por que ambas precisam de Ord
    (b) Qual seria o comportamento sem Ord?
    (c) Qual é mais eficiente?

25. Explique a diferença entre as classes Num, Integral e Fractional em Haskell.
    Dê exemplos de funções que usam cada uma.

26. Dada a árvore binária de busca:
    
    data BST a = Empty | Node a (BST a) (BST a)
    
    (a) Implemente search :: Ord a => a -> BST a -> Bool
    (b) Implemente height :: BST a -> Int
    (c) Implemente leaves :: BST a -> [a] (retorna folhas)
    (d) Implemente preOrder :: BST a -> [a]

27. Implemente usando list comprehension:
    
    (a) allPairs :: [a] -> [b] -> [(a,b)] que gera todos os pares
    (b) diagonal :: [[a]] -> [a] que extrai a diagonal principal
    (c) transpose' :: [[a]] -> [[a]] que transpõe uma matriz

28. Defina estas funções usando funções de alta ordem:
    
    (a) partition :: (a -> Bool) -> [a] -> ([a], [a])
    (b) groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
    (c) findIndices :: (a -> Bool) -> [a] -> [Int]

29. Implemente estas funções numéricas:
    
    (a) factorial :: Integer -> Integer usando foldr
    (b) gcd' :: Int -> Int -> Int (algoritmo de Euclides)
    (c) fibonacci :: Int -> Integer usando programação dinâmica

30. Problemas com strings:
    
    (a) isPalindrome :: String -> Bool
    (b) wordCount :: String -> Int
    (c) caesarCipher :: Int -> String -> String (cifra de César)

31. Usando unfold, implemente:
    
    (a) iterate' :: (a -> a) -> a -> [a]
    (b) unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
    (c) primeFactors :: Int -> [Int]

32. Defina um tipo de dados para representar expressões aritméticas:
    
    data Expr = Num Int | Add Expr Expr | Mul Expr Expr | Sub Expr Expr
    
    (a) eval :: Expr -> Int
    (b) toString :: Expr -> String
    (c) simplify :: Expr -> Expr (remove operações com 0 ou 1)

33. Trabalhando com Maybe:
    
    (a) safeDivide :: Double -> Double -> Maybe Double
    (b) chainMaybe :: Maybe a -> (a -> Maybe b) -> Maybe b
    (c) sequenceMaybe :: [Maybe a] -> Maybe [a]

34. Lista infinita e lazy evaluation:
    
    (a) primes :: [Int] (números primos infinitos usando crivo)
    (b) hamming :: [Int] (números de Hamming: 2^i * 3^j * 5^k)
    (c) pascalTriangle :: [[Int]] (triângulo de Pascal infinito)

35. Funções com acumuladores:
    
    (a) reverseAcc :: [a] -> [a] usando acumulador
    (b) lengthAcc :: [a] -> Int usando acumulador  
    (c) sumAcc :: [Int] -> Int usando acumulador

===============================================================================
DESAFIOS EXTRAS:

36. Implemente quicksort :: Ord a => [a] -> [a] usando list comprehension.

37. Crie um interpretador simples para uma linguagem com variáveis, atribuições
    e expressões aritméticas.

38. Implemente um sistema de tipos simples para verificar se expressões
    aritméticas são bem tipadas.

39. Use mônadas para implementar um parser simples que reconhece expressões
    matemáticas.

40. Implemente uma estrutura de dados persistente (como uma árvore AVL)
    com operações de inserção e remoção.

===============================================================================
Bom trabalho!
Exercícios elaborados com foco em programação funcional e Haskell.